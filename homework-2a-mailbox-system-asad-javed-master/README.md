# homework-2a-mailbox-system-asad-javed

message.h & message.c: Have 3 functions inside it. Typed struct message_t creates a messages with a sender ID, Reciever ID, and a message attached to it. Next, we have message_create which creates the message to be enter the mailbox. Initial message_t does not specify what is the message and which ID is sender's or reciever's. So in message create we define which int is sender ID, which int is reciever ID, and finally define the actual message being sent. Lastly, message_free releases any storage attached to the message after it is in the mailbox.

mailbox.h & maiilbox.c: Have 5 functions inside it. Mailbox_init establishes the mailbox itself and sets up number of addresses inside it. Mailbox -> entries refers to incoming information into the mailbox. It establishes how many addresses we are going to have. The For loop loops around after every entry and sets up the size of the mailbox, head(top of every address waitlist. Messages are taken from here to the address), and tail(end of every address waitlist. Incoming messages go to the tail). Mailbox_send deals with sending a message to a mailbox. We initally lock the pthread so that we do not have any other interference from any other messages and unlock it when we are done with the function. So after locking it we use an if statement saying that if the mailbox is full then make the message wait. Now when a message is recieved from a sender we put the message in tail since we want the message that were recieved first to go through first like a queue so the most recent recieved message goes to the bottom of the address list and waits for its turn. And since we added a message to the tail, we add 1 to the tail size and add 1 to the overall size of the mailbox. If the address was empty the message will go straight into it and pthread_cond_signal will update the mailbox and say that it is not empty anymore so that if a reciever comes to retrieve a message we can give it to the recieve function. Next is message_recieve. message_recieve deals with when a message is recieved. Again we start off with locking the pthread so we do not have any disruption when working with a message. Then we have an if statement that says that if size is 0 then we have to wait for it to be not empty be retrieve the message. Now once we have a message to be retrieved and the if statement passes then move on and take the message from the head since we queue messages in the form of head and tail. After taking that message we have to update the overall size by -1 since we took a message away and we have to update the head by adding 1 so that the queue keeps moving and we get anew message in the head for the next time. Message_recieve_poll is same as message_recieve. The only difference is that it does not have the if statement so if there is no message in the address, the function just returns null and if there is a message present in the address then it returns that message. Lastly we have message_available which checks if we have a message available in an address or not and returns 0 for no message and 1 for message available. Again we start off with locking the pthread and then we have an if statement which checks the size of the address. If the address empty it prints out no message and returns 0 and if there is a message it prints out message available and returns 1.
